<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<article>
  <articleinfo>
    <title>Erl8583 - Getting Started</title>

    <author>
      <firstname>CA</firstname>

      <surname>Meijer</surname>

      <affiliation>
        <orgname>hammingweight@gmail.com</orgname>
      </affiliation>
    </author>

    <pubdate>May 2011</pubdate>
  </articleinfo>

  <section>
    <title>Introduction</title>

    <para>Erl8583 is an Erlang library for generating and parsing ISO 8583
    messages.</para>
  </section>

  <section>
    <title>ISO 8583</title>

    <para>ISO 8583 is a standard that defines message types and content for
    electronic transactions using payment cards like credit and debit cards.
    There are three versions of the standard from 1987, from 1993 and from
    2003. The 1987 standard is the most widely adopted.</para>

    <para>An ISO 8583 message consists of three parts:</para>

    <para><itemizedlist>
        <listitem>
          <para>A message type identifier (MTI)</para>
        </listitem>

        <listitem>
          <para>One or more bitmaps that indicate what data elements are
          present in the message</para>
        </listitem>

        <listitem>
          <para>Data elements that contain values relevant to the transaction,
          e.g. the transaction date and amount</para>
        </listitem>
      </itemizedlist></para>

    <para>The next three sections cover the parts in a little detail.</para>

    <para></para>

    <section>
      <title>Message Type Identifier (MTI)</title>

      <para>The MTI is a 4 (decimai) digit number that encodes:</para>

      <para><itemizedlist>
          <listitem>
            <para>The version of the standard. The first digit of the MTI can
            have the value '0', '1' or '2' indicating that the 1987, 1993 or
            2003 version is used.</para>
          </listitem>

          <listitem>
            <para>The message class. The second digit specifies the purpose of
            the message, e.g. '1' denotes an authorization message, '2'
            indicates a financial message and '8' specifies a network
            administration message. See the ISO specifcation for the full list
            of message classes.</para>
          </listitem>

          <listitem>
            <para>The message function. The third digit indicates whether the
            message is a request ('0'), a response ('1'), an advice ('2'),
            etc.</para>
          </listitem>

          <listitem>
            <para>The message origin. The fourth digit indicates where the
            message originated and whether the message is a repeat, e.g. '0'
            indicates that the message originated from an acquiring
            institution while '1' denotes that the message is a repeat from an
            acquiring institution.</para>
          </listitem>
        </itemizedlist></para>

      <para></para>
    </section>

    <section>
      <title>Bitmap</title>

      <para>The 1987 specification of ISO 8583 defines 128 data elements that
      may be present in a message. The 1993 and 2003 versions define 192
      fields. Each data element is identified by an integer value in the range
      1-128 for the 1987 specification or 1-192 for the later specifications.
      The sender indicates which data elements are present in a message by one
      or more bitmaps. A bitmap is a collection of 64 bits; if a bit is set in
      the bitmap it indicates that a corresponding data element is
      present.</para>

      <para>The primary bitmap is used to indicate the presence or absence of
      data elements 1-64. The secondary bitmap is used for fields 65-128. If
      no data elements with identifier 65 or greater is present, there is no
      need for the secondary bitmap. The secondary bitmap is actually data
      element 1, so if bit 1 is set in the primary bitmap it indicates that
      the message contains the secondary bitmap.</para>

      <para>The tertiary bitmap is used for fields 129-192. The tertiary
      bitmap is data element 65, so if bit 65 of the secondary bitmap is set
      it indicates that the tertiary bitmap is used.</para>

      <para></para>
    </section>

    <section>
      <title>Data Elements</title>

      <para>An ISO 8583 message contains fields that carry the transaction
      information. Specific examples of data elements that might exist in a
      message are (from the 1987 specification): <itemizedlist>
          <listitem>
            <para>Field 1, the secondary bitmap</para>
          </listitem>

          <listitem>
            <para>Field 2, the primary account number (PAN)</para>
          </listitem>

          <listitem>
            <para>Field 4, the transaction amount</para>
          </listitem>

          <listitem>
            <para>Field 35, track 2 data (data read from a card's magnetic
            stripe)</para>
          </listitem>

          <listitem>
            <para>Field 98, the payee</para>
          </listitem>
        </itemizedlist></para>

      <para></para>

      <para>The fields listed above contain quite different data:
      <itemizedlist>
          <listitem>
            <para>Field 1 is binary data containing a sequence of bits</para>
          </listitem>

          <listitem>
            <para>Fields 2 and 4 contain numeric amounts</para>
          </listitem>

          <listitem>
            <para>Field 35 is encoded in a 4-bit format</para>
          </listitem>

          <listitem>
            <para>Field 98 contains a string with alphabetic characters</para>
          </listitem>
        </itemizedlist></para>

      <para></para>

      <para>ISO 8583 provides a format for describing acceptable contents for
      a field and for whether the field has fixed length or variable. The
      following abbreviations are used to describe the contents of
      fields:<itemizedlist>
          <listitem>
            <para><emphasis>b</emphasis> for binary data</para>
          </listitem>

          <listitem>
            <para><emphasis>n</emphasis> for numeric data</para>
          </listitem>

          <listitem>
            <para><emphasis>a</emphasis>, <emphasis>an</emphasis> and
            <emphasis>ans</emphasis> for various forms of strings</para>
          </listitem>

          <listitem>
            <para><emphasis>z</emphasis> for track 2 data</para>
          </listitem>
        </itemizedlist></para>

      <para></para>

      <para>To describe whether the field is of fixed or variable length, the
      following descriptors are used:</para>

      <itemizedlist>
        <listitem>
          <para>LLVAR, the field is of variable length and the length can be
          encoded in two decimal digits</para>
        </listitem>

        <listitem>
          <para>LLLVAR, the field is of variable length and the length can be
          encoded in three decimal digits</para>
        </listitem>

        <listitem>
          <para>fixed, the field length is fixed</para>
        </listitem>
      </itemizedlist>

      <para></para>

      <para>The table below shows the permitted content for some fields from
      the 1987 specification.<table>
          <title>Formats for some ISO 8583 data elements</title>

          <tgroup cols="5">
            <thead>
              <row>
                <entry>Field</entry>

                <entry>Name</entry>

                <entry>Format</entry>

                <entry>Content</entry>

                <entry>(Maximum) Length</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>2</entry>

                <entry>Primary Account Number</entry>

                <entry>LLVAR</entry>

                <entry><emphasis>n</emphasis></entry>

                <entry>19</entry>
              </row>

              <row>
                <entry>3</entry>

                <entry>Processing Code</entry>

                <entry>Fixed</entry>

                <entry><emphasis>n</emphasis></entry>

                <entry>6</entry>
              </row>

              <row>
                <entry>35</entry>

                <entry>Track 2 Data</entry>

                <entry>LLVAR</entry>

                <entry><emphasis>z</emphasis></entry>

                <entry>37</entry>
              </row>

              <row>
                <entry>42</entry>

                <entry>Card Acceptor Identification Code</entry>

                <entry>Fixed</entry>

                <entry><emphasis>ans</emphasis></entry>

                <entry>15</entry>
              </row>

              <row>
                <entry>63</entry>

                <entry>Reserved Private</entry>

                <entry>LLLVAR</entry>

                <entry><emphasis>ans</emphasis></entry>

                <entry>999</entry>
              </row>

              <row>
                <entry>64</entry>

                <entry>Message Authentication Code</entry>

                <entry>Fixed</entry>

                <entry><emphasis>b</emphasis></entry>

                <entry>64</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para></para>

      <para>The lengths of a field in Table 1 are expressed in terms of the
      field content and not in bytes. For example, a<emphasis> <emphasis>field
      of length 15 containing alphabetic characters might be encoded as 15
      bytes if the string contains ASCII characters but a binary field of
      length 64 might be encoded as 8 bytes if all 8 bits are used in each
      byte.</emphasis></emphasis></para>

      <para>It may happen that the contents of a fixed length field is less
      than the prescribed length in the ISO 8583 standard. If the value is
      shorter than the prescribed length: <itemizedlist>
          <listitem>
            <para>The contents must be padded with trailing spaces for fields
            that contain strings, e.g. for field 42 in Table 1.</para>
          </listitem>

          <listitem>
            <para>The contents must be padded with leading zeroes for numeric
            fields, e.g. for field 3 in Table 1.</para>

            <para></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Encoding ISO 8583 Messages</title>

      <para>ISO 8583 defines the acceptable content for the fields of an ISO
      8583 message; it does not describe how the fields must be encoded. This
      has led to different implementations of ISO 8583 adopting incompatible
      encodings. Here are some examples:<itemizedlist>
          <listitem>
            <para>A numeric (<emphasis>n</emphasis>) field of length 6 might
            be encoded as 6 BCD digits in 3 bytes or in 6 bytes as a string of
            6 characters.</para>
          </listitem>

          <listitem>
            <para>A string field might use the ASCII character set or EBCDIC
            characters.</para>
          </listitem>

          <listitem>
            <para>A binary (<emphasis>b</emphasis>) field might encode 8 bits
            of the value in 8 bits or the value might be converted to a
            hexadecimal string in which case the resultant encoding needs
            twice as many bytes as the original value.</para>
          </listitem>

          <listitem>
            <para>While ISO 8583 specifies that a message consists of an MTI,
            a bitmap and data elements, some implementations precede the
            message with a length field containing the length of the message.
            Other implementations append padding characters to the end of the
            message so that all messages have the same length.</para>
          </listitem>
        </itemizedlist></para>

      <para>One of the goals of erl8583 is to make it simple to encode ISO
      8583 messages irrespective of how some other party expects messages to
      be encoded.</para>
    </section>
  </section>

  <section>
    <title>Erl8583</title>

    <para>Erl8583 is a library that can be used to construct and parse ISO
    8583 messages for several encoding schemes used in practice. This section
    starts by describing how to install erl8583. The remainder of this section
    describes the modules that make up the erl8583 library.</para>

    <para>The definitive guide to the erl8583 API are the edocs in the
    distribution. This guide provides a high-level overview of the modules to
    help you get started. The modules can be classified into four
    types:</para>

    <para><itemizedlist>
        <listitem>
          <para>The erl8583_message module that provides a data structure for
          an ISO 8583 message.</para>
        </listitem>

        <listitem>
          <para>Encoding rules modules that specify the domain of ISO 8583
          data elements.</para>
        </listitem>

        <listitem>
          <para>Marshalling modules that are used to encode ISO 8583 messages
          or to decode byte streams into ISO 8583 messages.</para>
        </listitem>

        <listitem>
          <para>The erl8583_convert module that provides low-level conversions
          between data representations.</para>
        </listitem>
      </itemizedlist></para>

    <para></para>

    <section>
      <title>Installing erl8583</title>

      <para>To install erl8583, unzip the erlang archive into some directory
      accessible from your Erlang runtime (e.g. /usr/lib/erlang/lib). The
      archive adheres to the standard directory structure for an OTP
      application:<itemizedlist>
          <listitem>
            <para>beam files are in the ebin directory.</para>
          </listitem>

          <listitem>
            <para>Include files are in the include directory.</para>
          </listitem>

          <listitem>
            <para>EDoc API documentation files are in the doc
            directory.</para>
          </listitem>
        </itemizedlist></para>

      <para>The source code is included in the src directory and the EUnit
      unit tests are found in the test directory. Example Erlang files used in
      this guide are included in the src_examples directory.</para>

      <para></para>
    </section>

    <section>
      <title>The erl8583_message module</title>

      <para>The erl8583_message module provides a data type representing an
      ISO 8583 message. Some of the functions exposed by the module
      are:<itemizedlist>
          <listitem>
            <para><emphasis role="bold">new</emphasis> that creates a message
            data structure.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">set_mti</emphasis> and <emphasis
            role="bold">get_mti</emphasis> for setting and getting the MTI of
            an ISO 8583 message.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">set</emphasis> and <emphasis
            role="bold">get</emphasis> for setting and getting the value of a
            specified data element specified by its ID in the range 0-192. ISO
            8583 defines data elements with IDs in the range 1-192; ID 0 is an
            alias for the MTI.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">update</emphasis> for changing the
            value of a data element.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">get_fields</emphasis> that returns a
            list of the data element IDs that have been set for a
            message.</para>
          </listitem>
        </itemizedlist></para>

      <para>See the EDoc documentation for the complete list of functions and
      the arguments that are passed.</para>

      <para>Valid types for data element values are: strings, binaries and
      nested message instances. The API does not prevent you setting the value
      of a data element to be an atom, a tuple, an integer or a float but
      those types will cause an exception to be raised if you try to marshal
      (see section 3.3) the message. Note in particular that numeric
      (<emphasis>n</emphasis>) values should be encoded as strings; e.g. set
      the MTI as "0200" not as the integer 200.</para>

      <para>It may seem strange allowing data elements to be nested messages
      since ISO 8583 does not describe this scenario. However it is quite
      common to see data elements that are reserved for private use (e.g.
      field 127) to be nested messages. In such cases, one can refer to, say,
      field 127.3 which denotes sub field 3 in data element 127. The example
      in section 4.6 looks at such a case.</para>

      <para></para>
    </section>

    <section>
      <title>Encoding rules modules</title>

      <para>Section 2.3 described how ISO 8583 defines valid content for the
      data elements of a message. A data element is constrained by the
      permissible content (e.g. <emphasis>b</emphasis>,
      <emphasis>n</emphasis>, <emphasis>ans</emphasis>, etc), its format
      (fixed, LLVAR or LLVAR) and its length. Erl8583 has three modules
      (erl8583_fields, erl8583_fields_1993 and erl8583_fields_2003) that
      specify the permissible content for a data element based on the 1987,
      1993 and 2003 specifications (note that erl8583 currently doesn't
      support the 2003 specification). Each module exposes a function
      <emphasis role="bold">get_encoding</emphasis> that returns the valid
      content as a 3-tuple. The first element of the tuple is an atom that
      describes the content type (e.g. <emphasis>b</emphasis>,
      <emphasis>n</emphasis> or <emphasis>ans</emphasis>, etc). The second
      element of the tuple is an atom describing the format
      (<emphasis>fixed</emphasis>, <emphasis>llvar</emphasis> or
      <emphasis>lllvar</emphasis>). The third element of the tuple is the
      length specified as an integer. For the LLVAR and LLLVAR formats, the
      length denotes the maximum allowed length for the element.</para>

      <para>The code snippet below shows some of the implementation of the
      erl8583_fields module.<programlisting>-module(erl8583_fields).

%%
%% Include files
%%
%% @headerfile "../include/erl8583_types.hrl"
-include("erl8583_field_ids.hrl").
-include("erl8583_types.hrl").

%%
%% Exported Functions
%%
-export([get_encoding/1]).

%%
%% API Functions
%%

%% @doc Returns how a field is encoded as a triple consisting of the content 
%%      (e.g. ans, b, z, etc), the format (e.g. llvar, lllvar or fixed) and 
%%      the maximum length.
%%
%% @spec get_encoding(FieldId::integer()) -&gt; field_encoding()
-spec(get_encoding(integer()) -&gt; field_encoding()).

get_encoding(?MTI) -&gt;
	{n, fixed, 4};
get_encoding(?BITMAP_EXTENDED) -&gt;
	{b, fixed, 8};
get_encoding(?PAN) -&gt;
	{n, llvar, 19};
get_encoding(?PROC_CODE) -&gt;
	{n, fixed, 6};
%%
%% Code omitted...
%%
get_encoding(?TRACK_2_DATA) -&gt;
	{z, llvar, 37};
get_encoding(?TRACK_3_DATA) -&gt;
	{ans, lllvar, 104};
get_encoding(?RETRIEVAL_REF_NUM) -&gt;
	{an, fixed, 12};
%%
%% Code omitted...
%%
</programlisting></para>

      <para>The macros like <emphasis role="bold">MTI</emphasis>, <emphasis
      role="bold">BITMAP_EXTENDED</emphasis>, <emphasis
      role="bold">TRACK_2_DATA</emphasis>, etc. in the code listing are
      defined in the erl8583_field_ids.hrl header file.</para>

      <para></para>
    </section>

    <section>
      <title>Marshalling modules</title>

      <para>Foo</para>
    </section>

    <section>
      <title>The erl8583_convert module</title>

      <para>Foo</para>

      <para></para>
    </section>
  </section>
</article>
